@{
    ViewData["Title"] = "Bản đồ trạm sạc";
}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin />
<script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>

<style>
.leaflet-bar .locate-btn { display:block;width:32px;height:32px;line-height:32px;text-align:center; }
.leaflet-bar .locate-btn i { font-size:1rem; }
</style>

<div class="d-flex justify-content-between align-items-center mb-2">
    <h4 class="mb-0">@ViewData["Title"]</h4>
    <div class="d-flex gap-2 align-items-center">
        <div id="result-count" class="small text-body-secondary"></div>
        <button class="btn btn-outline-secondary" type="button" data-bs-toggle="offcanvas" data-bs-target="#filterCanvas">
            <i class="bi bi-sliders"></i> Bộ lọc
        </button>
    </div>
</div>

<div id="map" style="height:70vh;border-radius:.75rem;"></div>

<div class="offcanvas offcanvas-end border-0 shadow-sm" id="filterCanvas" tabindex="-1" aria-labelledby="filterLabel"
     data-bs-backdrop="true" data-bs-scroll="true" style="--bs-offcanvas-width:420px">
    <div class="offcanvas-header">
        <h5 id="filterLabel" class="mb-0"><i class="bi bi-funnel"></i> Bộ lọc</h5>
        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
    </div>
    <div class="offcanvas-body">
        <div class="vstack gap-3">
            <div>
                <label class="form-label">Thành phố</label>
                <input id="f-city" class="form-control" placeholder="TP.HCM, Hà Nội" />
            </div>
            <div>
                <label class="form-label">Loại trụ sạc</label>
                <select id="f-chargerType" class="form-select">
                    <option value="">Tất cả</option>
                    <option value="AC">AC</option>
                    <option value="DC">DC</option>
                    <option value="GB/T">GB/T</option>
                </select>
            </div>
            <div class="row g-2">
                <div class="col-6">
                    <label class="form-label">Công suất từ</label>
                    <div class="input-group">
                        <input id="f-minKw" type="number" step="0.1" min="0" class="form-control" placeholder="3.5" />
                        <span class="input-group-text">kW</span>
                    </div>
                </div>
                <div class="col-6">
                    <label class="form-label">Đến</label>
                    <div class="input-group">
                        <input id="f-maxKw" type="number" step="0.1" min="0" class="form-control" placeholder="180" />
                        <span class="input-group-text">kW</span>
                    </div>
                </div>
            </div>
            <div>
                <label class="form-label">Trạng thái trạm</label>
                <select id="f-status" class="form-select">
                    <option value="all">Tất cả</option>
                    <option value="online">Online</option>
                    <option value="offline">Offline</option>
                </select>
            </div>
            <button class="btn btn-primary w-100" id="btn-search">
                <i class="bi bi-search"></i> Áp dụng
            </button>
        </div>
    </div>
</div>

@section Scripts {
<script>
document.addEventListener('DOMContentLoaded', () => {
  const defaultCenter = [10.8231, 106.6297];
  const map = L.map('map').setView(defaultCenter, 12);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom: 19, attribution: '&copy; OpenStreetMap' }).addTo(map);

  const routeLayer = L.layerGroup().addTo(map);

  const numberVND = new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' });
  const formatDistance = (m) => !Number.isFinite(m) ? '—' : (m < 1000 ? `${Math.round(m)} m` : `${(m/1000).toFixed(m >= 10000 ? 0 : 1)} km`);
  const formatDuration = (s) => {
    if (!Number.isFinite(s)) return '—';
    const m = Math.round(s/60); if (m < 60) return `${m} phút`;
    const h = Math.floor(m/60), rm = m%60; return rm ? `${h} giờ ${rm} phút` : `${h} giờ`;
  };
  const formatKw = (kw) => {
    if (!Number.isFinite(kw)) return '—';
    const v = Number(kw), hasDecimal = Math.abs(v % 1) > 1e-6;
    return `${hasDecimal ? v.toFixed(1) : v.toFixed(0)}kW`;
  };

  const toRad = (deg) => deg*Math.PI/180;
  const haversine = (from, to) => {
    if (!from || !to) return NaN;
    const R=6371000,[lat1,lon1]=from,[lat2,lon2]=to,dLat=toRad(lat2-lat1),dLon=toRad(lon2-lon1);
    const a=Math.sin(dLat/2)**2+Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(a));
  };

  const invalidate = () => setTimeout(() => map.invalidateSize(), 200);
  window.addEventListener('resize', invalidate);
  const canvasEl = document.getElementById('filterCanvas');
  if (canvasEl) {
    canvasEl.addEventListener('shown.bs.offcanvas', invalidate);
    canvasEl.addEventListener('hidden.bs.offcanvas', invalidate);
  }

  let userLatLng = null, userMarker = null, accCircle = null, geoWatchId = null;

  const setUserLocation = (lat, lng, accuracy) => {
    userLatLng = [lat, lng];
    if (!userMarker) userMarker = L.marker(userLatLng, { title: 'Vị trí của bạn' }).addTo(map);
    else userMarker.setLatLng(userLatLng);
    if (accuracy && Number.isFinite(accuracy)) {
      if (!accCircle) accCircle = L.circle(userLatLng, { radius: accuracy, color: '#0d6efd', fillOpacity: 0.1 }).addTo(map);
      else accCircle.setLatLng(userLatLng).setRadius(accuracy);
    }
  };

  const stopGeoWatch = () => { if (geoWatchId != null) { navigator.geolocation.clearWatch(geoWatchId); geoWatchId = null; } };
  const locateUser = (recenterOnce = false) => {
    if (!navigator.geolocation) { console.warn('Trình duyệt không hỗ trợ Geolocation'); return; }
    let bestAcc = Number.POSITIVE_INFINITY, didRecenter = false;
    const handlePos = (pos) => {
      const { latitude, longitude, accuracy } = pos.coords;
      if (!Number.isFinite(latitude) || !Number.isFinite(longitude) || Math.abs(latitude) > 90 || Math.abs(longitude) > 180 || (latitude === 0 && longitude === 0)) return;
      if (accuracy + 5 < bestAcc) {
        bestAcc = accuracy; setUserLocation(latitude, longitude, accuracy);
        if (recenterOnce && !didRecenter) { map.setView([latitude, longitude], Math.max(map.getZoom(), 15), { animate: true }); didRecenter = true; }
      }
      if (bestAcc <= 40) stopGeoWatch();
    };
    const handleErr = (err) => console.warn('Không thể lấy vị trí người dùng:', err.message);
    navigator.geolocation.getCurrentPosition(handlePos, handleErr, { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 });
    geoWatchId = navigator.geolocation.watchPosition(handlePos, handleErr, { enableHighAccuracy: true, maximumAge: 0 });
    setTimeout(stopGeoWatch, 15000);
  };

  const locateControl = L.control({ position: 'topleft' });
  locateControl.onAdd = function () { const div = L.DomUtil.create('div', 'leaflet-bar'); const a = L.DomUtil.create('a', 'locate-btn', div); a.href='#'; a.title='Về vị trí của tôi'; a.innerHTML="<i class='bi bi-geo-alt'></i>"; L.DomEvent.on(a,'click',(e)=>{L.DomEvent.stop(e);locateUser(true);}); return div; };
  locateControl.addTo(map);

  const clearRoute = () => routeLayer.clearLayers();
  const clearRouteControl = L.control({ position: 'topleft' });
  clearRouteControl.onAdd = function () { const div = L.DomUtil.create('div','leaflet-bar'); const a = L.DomUtil.create('a','locate-btn',div); a.href='#'; a.title='Xoá lộ trình'; a.innerHTML="<i class='bi bi-x-lg'></i>"; L.DomEvent.on(a,'click',(e)=>{L.DomEvent.stop(e);clearRoute();}); return div; };
  clearRouteControl.addTo(map);

  async function drawRoute(fromLatLng, toLatLng, infoEl) {
    try {
      clearRoute();
      const [fromLat, fromLng] = fromLatLng, [toLat, toLng] = toLatLng;
      const url = `https://router.project-osrm.org/route/v1/driving/${fromLng},${fromLat};${toLng},${toLat}?overview=full&geometries=geojson`;
      const res = await fetch(url); if (!res.ok) throw new Error('OSRM request failed');
      const data = await res.json(); if (!data.routes?.length) throw new Error('No route found');
      const route = data.routes[0];
      const geo = L.geoJSON(route.geometry, { style: { color: '#0d6efd', weight: 4 } }).addTo(routeLayer);
      try { map.fitBounds(geo.getBounds(), { padding: [24, 24] }); } catch {}
      const dist = formatDistance(route.distance), dur = formatDuration(route.duration);
      if (infoEl) infoEl.textContent = `Quãng đường (ô tô): ${dist} • Ước tính: ${dur}`;
    } catch (e) {
      console.warn('Routing error', e);
      if (infoEl) infoEl.textContent = 'Không vẽ được lộ trình, vui lòng thử lại.';
    }
  }

  let markers = [];
  const clearMarkers = () => { markers.forEach(m => map.removeLayer(m)); markers = []; };

  const isValidCoord = (lat,lng) => Number.isFinite(lat) && Number.isFinite(lng) && Math.abs(lat) <= 90 && Math.abs(lng) <= 180;
  const normalizeLatLng = (rawLat, rawLng) => {
    let lat = Number(rawLat), lng = Number(rawLng);
    if (isValidCoord(lat, lng)) return { lat, lng };
    if (isValidCoord(Number(rawLng), Number(rawLat))) { console.warn('Swapped lat/lng detected, auto-correcting.', { rawLat, rawLng }); return { lat: Number(rawLng), lng: Number(rawLat) }; }
    return { lat: NaN, lng: NaN };
  };

  async function loadData() {
    const city = document.getElementById('f-city').value.trim();
    const chargerType = document.getElementById('f-chargerType').value;
    const minKw = parseFloat(document.getElementById('f-minKw').value);
    const maxKw = parseFloat(document.getElementById('f-maxKw').value);
    const status = document.getElementById('f-status').value;

    const url = new URL('/Stations/MapData', window.location.origin);
    if (city) url.searchParams.set('city', city);
    if (chargerType) url.searchParams.set('chargerType', chargerType);
    if (!Number.isNaN(minKw)) url.searchParams.set('minPowerKw', String(minKw));
    if (!Number.isNaN(maxKw)) url.searchParams.set('maxPowerKw', String(maxKw));
    if (status === 'online') url.searchParams.set('online', 'true');
    else if (status === 'offline') url.searchParams.set('online', 'false');

    let data = [];
    try {
      const res = await fetch(url, { headers: { 'Accept': 'application/json' }});
      data = res.ok ? await res.json() : [];
    } catch { data = []; }

    clearMarkers();
    const bounds = [];
    let visible = 0;

    data.forEach((s, idx) => {
      const { lat, lng } = normalizeLatLng(s.lat, s.lng);
      if (!isValidCoord(lat, lng)) return;

      const approxDist = userLatLng ? haversine(userLatLng, [lat, lng]) : NaN;
      const approxLine = userLatLng ? `<div class='text-body-secondary'>Cách bạn (đường chim bay): ${formatDistance(approxDist)}</div>` : '';

      let detailsHtml = '';
      if (Array.isArray(s.chargers) && s.chargers.length) {
        detailsHtml = s.chargers.map(c => {
          const type = c.type || '—';
          const pwr = formatKw(c.maxPowerKw);
          const price = Number.isFinite(c.pricePerKwh) ? `${numberVND.format(c.pricePerKwh)}/kWh` : '—';
          const avail = Number.isFinite(c.available) ? c.available : 0;
          const total = Number.isFinite(c.total) ? c.total : 0;
          return `[${type} - ${pwr}] | slot trống ${avail}/${total} cổng | ${price}.`;
        }).join('<br/>');
      } else {
        detailsHtml = (s.ports || []).map(p => {
          const typ = p.connectorType ?? 'N/A';
          const price = `${numberVND.format(p.pricePerKwh ?? 0)}/kWh`;
          return `[${typ}] | ${p.status ?? '—'} | ${price}.`;
        }).join('<br/>') || 'Chưa có dữ liệu cổng';
      }

      const gmapUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=driving`;
      const routeInfoId = `route-info-${idx}`;
      const hoursText = s.hours ? ` | Thời gian hoạt động ${s.hours}` : '';

      const html = `<div class='small'>
                      <div class='d-flex justify-content-between align-items-center'>
                        <strong>${s.name}</strong>
                        <div class='btn-group'>
                          <a class='btn btn-outline-primary btn-sm' href='${gmapUrl}' target='_blank' rel='noopener' title='Mở Google Maps'>
                            <i class='bi bi-sign-turn-right-fill'></i>
                          </a>
                          <button type='button' class='btn btn-primary btn-sm btn-route' data-lat='${lat}' data-lng='${lng}' data-target='${routeInfoId}' title='Vẽ lộ trình trên bản đồ'>
                            <i class='bi bi-signpost'></i>
                          </button>
                        </div>
                      </div>
                      <span class='text-body-secondary'>${s.city ?? ''}${hoursText}</span>
                      ${approxLine}
                      <div id='${routeInfoId}' class='mt-1 fw-semibold'></div>
                      <hr class='my-1'/>
                      ${detailsHtml}
                    </div>`;

      const marker = L.marker([lat, lng], { title: s.name }).bindPopup(html, { minWidth: 300 });
      marker.addTo(map);
      markers.push(marker);
      bounds.push([lat, lng]);
      visible++;
    });

    document.getElementById('result-count').innerText = `${visible} trạm phù hợp`;

    if (userLatLng) bounds.push(userLatLng);
    if (bounds.length) { try { map.fitBounds(bounds, { padding: [24, 24] }); } catch (e) { console.warn('fitBounds failed', e); } }
  }

  map.on('popupopen', (e) => {
    const root = e.popup.getElement(); if (!root) return;
    const btn = root.querySelector('.btn-route'); if (!btn) return;
    btn.addEventListener('click', async () => {
      if (!userLatLng) { alert('Chưa có vị trí của bạn. Vui lòng bật định vị.'); return; }
      const lat = Number(btn.dataset.lat), lng = Number(btn.dataset.lng), targetId = btn.dataset.target;
      const infoEl = root.querySelector(`#${CSS.escape(targetId)}`); if (infoEl) infoEl.textContent = 'Đang tính lộ trình...';
      await drawRoute(userLatLng, [lat, lng], infoEl);
    }, { once: true });
  });

  document.getElementById('btn-search').addEventListener('click', async () => {
    await loadData();
    const bsOffcanvas = bootstrap.Offcanvas.getOrCreateInstance(document.getElementById('filterCanvas'));
    bsOffcanvas.hide();
  });

  locateUser(true);
  loadData();
});
</script>
}